-- Migration: Add SMS Authentication Support
-- Description: Adds support for SMS-based MFA authentication with phone verification

-- Create SMS verification codes table
CREATE TABLE IF NOT EXISTS public.sms_verification_codes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    phone_number TEXT NOT NULL,
    country_code TEXT NOT NULL DEFAULT '+225',
    code VARCHAR(6) NOT NULL,
    code_hash VARCHAR(255) NOT NULL, -- Hashed version for security
    purpose VARCHAR(20) NOT NULL DEFAULT 'mfa' CHECK (purpose IN ('mfa', 'login', 'phone_verification', 'password_reset')),
    attempts INTEGER NOT NULL DEFAULT 0,
    max_attempts INTEGER NOT NULL DEFAULT 3,
    expires_at TIMESTAMPTZ NOT NULL,
    used_at TIMESTAMPTZ NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    ip_address INET NULL,
    user_agent TEXT NULL,
    device_fingerprint TEXT NULL
);

-- Create phone verification table
CREATE TABLE IF NOT EXISTS public.phone_verifications (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    phone_number TEXT NOT NULL,
    country_code TEXT NOT NULL DEFAULT '+225',
    is_verified BOOLEAN NOT NULL DEFAULT FALSE,
    verification_method VARCHAR(20) NOT NULL DEFAULT 'sms' CHECK (verification_method IN ('sms', 'call', 'whatsapp')),
    verified_at TIMESTAMPTZ NULL,
    verification_attempts INTEGER NOT NULL DEFAULT 0,
    last_verification_attempt TIMESTAMPTZ NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(user_id, phone_number)
);

-- Create SMS rate limiting table
CREATE TABLE IF NOT EXISTS public.sms_rate_limits (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    identifier TEXT NOT NULL, -- Can be phone_number, ip_address, or user_id
    identifier_type VARCHAR(20) NOT NULL CHECK (identifier_type IN ('phone', 'ip', 'user_id')),
    purpose VARCHAR(20) NOT NULL DEFAULT 'mfa' CHECK (purpose IN ('mfa', 'login', 'phone_verification', 'password_reset')),
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    window_end TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '1 hour'),
    is_blocked BOOLEAN NOT NULL DEFAULT FALSE,
    block_until TIMESTAMPTZ NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create SMS delivery logs table
CREATE TABLE IF NOT EXISTS public.sms_delivery_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NULL REFERENCES auth.users(id) ON DELETE SET NULL,
    phone_number TEXT NOT NULL,
    country_code TEXT NOT NULL DEFAULT '+225',
    purpose VARCHAR(20) NOT NULL CHECK (purpose IN ('mfa', 'login', 'phone_verification', 'password_reset', 'notification')),
    message_id TEXT NULL, -- Provider message ID (e.g., Twilio SID)
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'delivered', 'failed', 'expired')),
    provider VARCHAR(50) NOT NULL DEFAULT 'twilio',
    provider_response TEXT NULL,
    error_code TEXT NULL,
    error_message TEXT NULL,
    cost DECIMAL(10, 4) NULL,
    currency CHAR(3) NULL DEFAULT 'USD',
    sent_at TIMESTAMPTZ NULL,
    delivered_at TIMESTAMPTZ NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add SMS preferences to user profiles
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS sms_enabled BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS phone_verified BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS phone_verified_at TIMESTAMPTZ NULL,
ADD COLUMN IF NOT EXISTS preferred_mfa_method VARCHAR(20) DEFAULT 'totp' CHECK (preferred_mfa_method IN ('totp', 'sms', 'backup')),
ADD COLUMN IF NOT EXISTS country_code TEXT DEFAULT '+225';

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_sms_verification_codes_user_id ON public.sms_verification_codes(user_id);
CREATE INDEX IF NOT EXISTS idx_sms_verification_codes_phone ON public.sms_verification_codes(phone_number);
CREATE INDEX IF NOT EXISTS idx_sms_verification_codes_expires_at ON public.sms_verification_codes(expires_at);
CREATE INDEX IF NOT EXISTS idx_sms_verification_codes_purpose ON public.sms_verification_codes(purpose);

CREATE INDEX IF NOT EXISTS idx_phone_verifications_user_id ON public.phone_verifications(user_id);
CREATE INDEX IF NOT EXISTS idx_phone_verifications_phone ON public.phone_verifications(phone_number);
CREATE INDEX IF NOT EXISTS idx_phone_verifications_is_verified ON public.phone_verifications(is_verified);

CREATE INDEX IF NOT EXISTS idx_sms_rate_limits_identifier ON public.sms_rate_limits(identifier, identifier_type);
CREATE INDEX IF NOT EXISTS idx_sms_rate_limits_window ON public.sms_rate_limits(window_start, window_end);
CREATE INDEX IF NOT EXISTS idx_sms_rate_limits_is_blocked ON public.sms_rate_limits(is_blocked);

CREATE INDEX IF NOT EXISTS idx_sms_delivery_logs_user_id ON public.sms_delivery_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_sms_delivery_logs_phone ON public.sms_delivery_logs(phone_number);
CREATE INDEX IF NOT EXISTS idx_sms_delivery_logs_status ON public.sms_delivery_logs(status);
CREATE INDEX IF NOT EXISTS idx_sms_delivery_logs_created_at ON public.sms_delivery_logs(created_at);

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Add triggers for updated_at
CREATE TRIGGER update_sms_verification_codes_updated_at
    BEFORE UPDATE ON public.sms_verification_codes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_phone_verifications_updated_at
    BEFORE UPDATE ON public.phone_verifications
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_sms_rate_limits_updated_at
    BEFORE UPDATE ON public.sms_rate_limits
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_sms_delivery_logs_updated_at
    BEFORE UPDATE ON public.sms_delivery_logs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to generate and send SMS verification code
CREATE OR REPLACE FUNCTION public.send_sms_verification_code(
    p_user_id UUID,
    p_phone_number TEXT,
    p_purpose VARCHAR(20) DEFAULT 'mfa',
    p_country_code VARCHAR(10) DEFAULT '+225',
    p_ip_address INET DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL
)
RETURNS TABLE (
    success BOOLEAN,
    message TEXT,
    rate_limited BOOLEAN,
    next_allowed_at TIMESTAMPTZ
) AS $$
DECLARE
    v_code VARCHAR(6);
    v_code_hash VARCHAR(255);
    v_expires_at TIMESTAMPTZ;
    v_attempts_remaining INTEGER;
    v_rate_limit_ok BOOLEAN;
    v_next_allowed_at TIMESTAMPTZ;
    v_clean_phone TEXT;
BEGIN
    -- Clean and validate phone number
    v_clean_phone := REGEXP_REPLACE(p_phone_number, '[^0-9+]', '', 'g');

    -- Check rate limiting
    SELECT
        COUNT(*) < 5 as ok,
        MAX(window_end) as next_allowed
    INTO v_rate_limit_ok, v_next_allowed_at
    FROM public.sms_rate_limits
    WHERE identifier = v_clean_phone
        AND identifier_type = 'phone'
        AND purpose = p_purpose
        AND window_start > NOW() - INTERVAL '1 hour';

    IF NOT v_rate_limit_ok THEN
        RETURN QUERY SELECT
            FALSE::BOOLEAN,
            'Trop de SMS envoyés. Veuillez réessayer plus tard.'::TEXT,
            TRUE::BOOLEAN,
            v_next_allowed_at;
        RETURN;
    END IF;

    -- Generate random 6-digit code
    v_code := LPAD(FLOOR(RANDOM() * 1000000)::TEXT, 6, '0');

    -- Hash the code for security
    v_code_hash := CRYPT(v_code || COALESCE(p_user_id::TEXT, ''), GEN_SALT('bf'));

    -- Set expiration (5 minutes for most purposes, 15 minutes for password reset)
    IF p_purpose = 'password_reset' THEN
        v_expires_at := NOW() + INTERVAL '15 minutes';
    ELSE
        v_expires_at := NOW() + INTERVAL '5 minutes';
    END IF;

    -- Insert verification code
    INSERT INTO public.sms_verification_codes (
        user_id, phone_number, country_code, code, code_hash,
        purpose, expires_at, ip_address, user_agent
    ) VALUES (
        p_user_id, v_clean_phone, p_country_code, v_code, v_code_hash,
        p_purpose, v_expires_at, p_ip_address, p_user_agent
    );

    -- Update rate limiting
    INSERT INTO public.sms_rate_limits (
        identifier, identifier_type, purpose, count, window_start, window_end
    ) VALUES (
        v_clean_phone, 'phone', p_purpose, 1, NOW(), NOW() + INTERVAL '1 hour'
    )
    ON CONFLICT (identifier, identifier_type, purpose, window_start)
    DO UPDATE SET
        count = sms_rate_limits.count + 1,
        updated_at = NOW();

    -- Log SMS delivery attempt
    INSERT INTO public.sms_delivery_logs (
        user_id, phone_number, country_code, purpose, status, provider
    ) VALUES (
        p_user_id, v_clean_phone, p_country_code, p_purpose, 'pending', 'twilio'
    );

    -- In development, return the code for testing
    IF current_setting('app_environment', true) = 'development' THEN
        RETURN QUERY SELECT
            TRUE::BOOLEAN,
            'Code SMS généré: ' || v_code || ' (mode développement)'::TEXT,
            FALSE::BOOLEAN,
            NULL::TIMESTAMPTZ;
    ELSE
        RETURN QUERY SELECT
            TRUE::BOOLEAN,
            'Code SMS envoyé avec succès'::TEXT,
            FALSE::BOOLEAN,
            NULL::TIMESTAMPTZ;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to verify SMS code
CREATE OR REPLACE FUNCTION public.verify_sms_code(
    p_user_id UUID,
    p_phone_number TEXT,
    p_code VARCHAR(6),
    p_purpose VARCHAR(20) DEFAULT 'mfa'
)
RETURNS TABLE (
    success BOOLEAN,
    message TEXT,
    attempts_remaining INTEGER,
    is_locked BOOLEAN,
    locked_until TIMESTAMPTZ
) AS $$
DECLARE
    v_verification_record RECORD;
    v_clean_phone TEXT;
    v_code_valid BOOLEAN;
    v_attempts_remaining INTEGER;
    v_is_locked BOOLEAN;
    v_locked_until TIMESTAMPTZ;
BEGIN
    -- Clean phone number
    v_clean_phone := REGEXP_REPLACE(p_phone_number, '[^0-9+]', '', 'g');

    -- Find the verification record
    SELECT * INTO v_verification_record
    FROM public.sms_verification_codes
    WHERE user_id = p_user_id
        AND phone_number = v_clean_phone
        AND purpose = p_purpose
        AND used_at IS NULL
        AND expires_at > NOW()
    ORDER BY created_at DESC
    LIMIT 1;

    -- Check if record exists
    IF v_verification_record IS NULL THEN
        RETURN QUERY SELECT
            FALSE::BOOLEAN,
            'Code invalide ou expiré'::TEXT,
            0::INTEGER,
            FALSE::BOOLEAN,
            NULL::TIMESTAMPTZ;
        RETURN;
    END IF;

    -- Check if account is locked due to too many attempts
    IF v_verification_record.attempts >= v_verification_record.max_attempts THEN
        v_is_locked := TRUE;
        v_locked_until := v_verification_record.updated_at + INTERVAL '5 minutes';

        RETURN QUERY SELECT
            FALSE::BOOLEAN,
            'Compte temporairement bloqué suite à trop de tentatives'::TEXT,
            0::INTEGER,
            TRUE::BOOLEAN,
            v_locked_until;
        RETURN;
    END IF;

    -- Verify the code (using hash comparison)
    v_code_valid := (v_verification_record.code_hash = CRYPT(p_code || p_user_id::TEXT, v_verification_record.code_hash));

    IF v_code_valid THEN
        -- Mark as used
        UPDATE public.sms_verification_codes
        SET used_at = NOW()
        WHERE id = v_verification_record.id;

        -- Update phone verification if this is phone verification purpose
        IF p_purpose = 'phone_verification' THEN
            INSERT INTO public.phone_verifications (user_id, phone_number, is_verified, verified_at)
            VALUES (p_user_id, v_clean_phone, TRUE, NOW())
            ON CONFLICT (user_id, phone_number)
            DO UPDATE SET
                is_verified = TRUE,
                verified_at = NOW(),
                verification_attempts = phone_verifications.verification_attempts + 1,
                updated_at = NOW();

            -- Update profile
            UPDATE public.profiles
            SET
                phone_verified = TRUE,
                phone_verified_at = NOW()
            WHERE id = p_user_id;
        END IF;

        RETURN QUERY SELECT
            TRUE::BOOLEAN,
            'Code vérifié avec succès'::TEXT,
            v_verification_record.max_attempts - v_verification_record.attempts - 1,
            FALSE::BOOLEAN,
            NULL::TIMESTAMPTZ;
    ELSE
        -- Increment attempt count
        v_attempts_remaining := v_verification_record.max_attempts - v_verification_record.attempts - 1;

        UPDATE public.sms_verification_codes
        SET attempts = attempts + 1,
            updated_at = NOW()
        WHERE id = v_verification_record.id;

        -- Update phone verification attempts if needed
        IF p_purpose = 'phone_verification' THEN
            INSERT INTO public.phone_verifications (user_id, phone_number, verification_attempts, last_verification_attempt)
            VALUES (p_user_id, v_clean_phone, 1, NOW())
            ON CONFLICT (user_id, phone_number)
            DO UPDATE SET
                verification_attempts = phone_verifications.verification_attempts + 1,
                last_verification_attempt = NOW(),
                updated_at = NOW();
        END IF;

        -- Check if this was the last attempt
        IF v_attempts_remaining <= 0 THEN
            v_is_locked := TRUE;
            v_locked_until := NOW() + INTERVAL '5 minutes';

            RETURN QUERY SELECT
                FALSE::BOOLEAN,
                'Code invalide. Trop de tentatives. Compte bloqué.'::TEXT,
                0::INTEGER,
                TRUE::BOOLEAN,
                v_locked_until;
        ELSE
            RETURN QUERY SELECT
                FALSE::BOOLEAN,
                'Code invalide'::TEXT,
                v_attempts_remaining,
                FALSE::BOOLEAN,
                NULL::TIMESTAMPTZ;
        END IF;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Enable RLS
ALTER TABLE public.sms_verification_codes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.phone_verifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sms_rate_limits ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sms_delivery_logs ENABLE ROW LEVEL SECURITY;

-- RLS Policies for sms_verification_codes
CREATE POLICY "Users can view their own SMS verification codes" ON public.sms_verification_codes
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own SMS verification codes" ON public.sms_verification_codes
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- RLS Policies for phone_verifications
CREATE POLICY "Users can view their own phone verifications" ON public.phone_verifications
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own phone verifications" ON public.phone_verifications
    FOR UPDATE USING (auth.uid() = user_id);

-- RLS Policies for sms_delivery_logs
CREATE POLICY "Users can view their own SMS delivery logs" ON public.sms_delivery_logs
    FOR SELECT USING (auth.uid() = user_id);

-- Grant permissions
GRANT SELECT, INSERT ON public.sms_verification_codes TO authenticated;
GRANT SELECT ON public.sms_verification_codes TO anon;

GRANT SELECT, INSERT, UPDATE ON public.phone_verifications TO authenticated;
GRANT SELECT ON public.phone_verifications TO anon;

GRANT SELECT, INSERT ON public.sms_delivery_logs TO authenticated;
GRANT SELECT ON public.sms_delivery_logs TO anon;

-- Grant execute permissions for functions
GRANT EXECUTE ON FUNCTION public.send_sms_verification_code TO authenticated;
GRANT EXECUTE ON FUNCTION public.verify_sms_code TO authenticated;

-- Add comments for documentation
COMMENT ON TABLE public.sms_verification_codes IS 'Stores SMS verification codes for MFA and phone verification';
COMMENT ON TABLE public.phone_verifications IS 'Tracks phone number verification status';
COMMENT ON TABLE public.sms_rate_limits IS 'Rate limiting for SMS sending';
COMMENT ON TABLE public.sms_delivery_logs IS 'Logs SMS delivery attempts and status';

COMMENT ON FUNCTION public.send_sms_verification_code IS 'Generates and sends SMS verification code';
COMMENT ON FUNCTION public.verify_sms_code IS 'Verifies SMS verification code';