-- Migration pour les Rapports Mensuels Automatisés
-- Implémentation complète selon les user stories admin avec génération PDF/CSV

-- Table principale pour les rapports mensuels
CREATE TABLE IF NOT EXISTS monthly_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title VARCHAR(255) NOT NULL,
  month INTEGER NOT NULL CHECK (month >= 1 AND month <= 12),
  year INTEGER NOT NULL CHECK (year >= 2020 AND year <= 2100),
  status VARCHAR(50) NOT NULL DEFAULT 'draft' CHECK (status IN (
    'draft', 'generated', 'sent', 'failed'
  )),

  -- Contenu du rapport
  metrics JSONB NOT NULL DEFAULT '{}',
  comparison JSONB DEFAULT '{}',
  executive_summary TEXT,

  -- Fichiers générés
  pdf_url TEXT,
  csv_url TEXT,
  excel_url TEXT,

  -- Envoi
  recipients TEXT[] DEFAULT '{}',
  sent_at TIMESTAMPTZ,
  send_error TEXT,

  -- Génération
  generated_at TIMESTAMPTZ,
  generated_by UUID REFERENCES auth.users(id),
  generation_duration_ms INTEGER,

  -- Métadonnées
  report_version VARCHAR(20) DEFAULT '1.0',
  locale VARCHAR(10) DEFAULT 'fr-FR',
  timezone VARCHAR(50) DEFAULT 'Africa/Abidjan',

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- Contrainte d'unicité
  UNIQUE(month, year)
);

-- Table pour les modèles de rapports
CREATE TABLE IF NOT EXISTS report_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  description TEXT,
  type VARCHAR(50) NOT NULL CHECK (type IN (
    'monthly_performance', 'quarterly_review', 'annual_summary', 'custom'
  )),

  -- Configuration du modèle
  template_config JSONB NOT NULL DEFAULT '{}',
  sections JSONB NOT NULL DEFAULT '{}',
  styling JSONB DEFAULT '{}',

  -- Gestion
  is_default BOOLEAN DEFAULT FALSE,
  is_active BOOLEAN DEFAULT TRUE,
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Table pour le suivi d'envoi des rapports
CREATE TABLE IF NOT EXISTS report_delivery_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  report_id UUID REFERENCES monthly_reports(id) ON DELETE CASCADE,
  recipient_email VARCHAR(255) NOT NULL,
  delivery_method VARCHAR(50) NOT NULL CHECK (delivery_method IN (
    'email', 'webhook', 'api', 'download'
  )),

  -- Statut de livraison
  delivery_status VARCHAR(50) NOT NULL DEFAULT 'pending' CHECK (delivery_status IN (
    'pending', 'sent', 'delivered', 'failed', 'bounced', 'opened'
  )),

  -- Timestamps
  sent_at TIMESTAMPTZ,
  delivered_at TIMESTAMPTZ,
  opened_at TIMESTAMPTZ,

  -- Métriques
  delivery_duration_ms INTEGER,
  error_message TEXT,
  tracking_id VARCHAR(100),

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Fonction principale pour générer un rapport mensuel
CREATE OR REPLACE FUNCTION generate_monthly_report(
  p_month INTEGER,
  p_year INTEGER,
  p_title VARCHAR(255) DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  report_id UUID;
  start_date DATE;
  end_date DATE;
  previous_start_date DATE;
  previous_end_date DATE;
  current_user_id UUID := auth.uid();
  start_time TIMESTAMPTZ := NOW();

  -- Variables pour les métriques
  total_users BIGINT;
  new_users BIGINT;
  active_users BIGINT;
  total_properties BIGINT;
  new_properties BIGINT;
  total_applications BIGINT;
  successful_applications BIGINT;
  avg_monthly_rent DECIMAL(12,2);
  total_rent_value DECIMAL(15,2);

  -- Variables pour la comparaison
  previous_total_users BIGINT;
  previous_total_properties BIGINT;
  previous_successful_applications BIGINT;

  -- Variables pour les répartitions
  region_breakdown JSONB := '{}';
  user_type_breakdown JSONB := '{}';

  report_title VARCHAR(255);
  executive_summary TEXT;
BEGIN
  -- Valider les paramètres
  IF p_month < 1 OR p_month > 12 THEN
    RAISE EXCEPTION 'Mois invalide: %', p_month;
  END IF;

  IF p_year < 2020 OR p_year > 2100 THEN
    RAISE EXCEPTION 'Année invalide: %', p_year;
  END IF;

  -- Calculer les dates
  start_date := DATE_MAKE_DATE(p_year, p_month, 1);
  end_date := (start_date + INTERVAL '1 month' - INTERVAL '1 day')::DATE;
  previous_start_date := (start_date - INTERVAL '1 month')::DATE;
  previous_end_date := (end_date - INTERVAL '1 month' - INTERVAL '1 day')::DATE;

  -- Titre par défaut
  report_title := COALESCE(p_title,
    'Rapport Mensuel - ' || TO_CHAR(start_date, 'Month YYYY', 'fr_FR')
  );

  -- Calculer les métriques du mois actuel
  SELECT COUNT(*) INTO total_users
  FROM profiles;

  SELECT COUNT(*) INTO new_users
  FROM profiles
  WHERE created_at >= start_date AND created_at <= end_date;

  -- Utilisateurs actifs = connectés dans les 30 derniers jours
  SELECT COUNT(DISTINCT user_id) INTO active_users
  FROM user_sessions
  WHERE session_start >= (end_date - INTERVAL '30 days') AND session_start <= end_date;

  SELECT COUNT(*) INTO total_properties
  FROM properties
  WHERE deleted_at IS NULL;

  SELECT COUNT(*) INTO new_properties
  FROM properties
  WHERE created_at >= start_date AND created_at <= end_date AND deleted_at IS NULL;

  SELECT COUNT(*) INTO total_applications
  FROM rental_applications
  WHERE created_at >= start_date AND created_at <= end_date;

  SELECT COUNT(*) INTO successful_applications
  FROM rental_applications
  WHERE created_at >= start_date AND created_at <= end_date
  AND status = 'approved';

  -- Calculer le loyer moyen et la valeur totale
  SELECT
    COALESCE(AVG(monthly_rent), 0) INTO avg_monthly_rent,
    COALESCE(SUM(monthly_rent), 0) INTO total_rent_value
  FROM properties
  WHERE created_at >= start_date AND created_at <= end_date AND deleted_at IS NULL;

  -- Calculer les métriques du mois précédent pour comparaison
  SELECT COUNT(*) INTO previous_total_users
  FROM profiles
  WHERE created_at < previous_start_date;

  SELECT COUNT(*) INTO previous_total_properties
  FROM properties
  WHERE created_at < previous_start_date AND deleted_at IS NULL;

  SELECT COUNT(*) INTO previous_successful_applications
  FROM rental_applications
  WHERE created_at >= previous_start_date AND created_at <= previous_end_date
  AND status = 'approved';

  -- Répartition par région (top 10 villes)
  SELECT jsonb_object_agg(city, property_count) INTO region_breakdown
  FROM (
    SELECT
      city,
      COUNT(*) as property_count
    FROM properties
    WHERE city IS NOT NULL AND deleted_at IS NULL
    GROUP BY city
    ORDER BY property_count DESC
    LIMIT 10
  ) region_stats;

  -- Répartition par type d'utilisateur
  SELECT jsonb_object_agg(user_type, user_count) INTO user_type_breakdown
  FROM (
    SELECT
      user_type,
      COUNT(*) as user_count
    FROM profiles
    WHERE user_type IS NOT NULL
    GROUP BY user_type
  ) user_type_stats;

  -- Générer le résumé exécutif
  executive_summary := format(
    'Période du %s au %s

UTILISATEURS:
- Total utilisateurs: %s (+%s ce mois)
- Nouveaux utilisateurs: %s
- Taux de croissance: %s%%

PROPRIÉTÉS:
- Total propriétés: %s (+%s ce mois)
- Nouvelles propriétés: %s
- Loyer moyen: %s FCFA
- Valeur locative totale: %s FCFA

CANDIDATURES:
- Total candidatures: %s
- Candidatures approuvées: %s
- Taux de conversion: %s%%

PERFORMANCE:
- Croissance utilisateurs: %s%%
- Croissance propriétés: %s%%
- Taux de conversion global: %s%%',
    TO_CHAR(start_date, 'DD/MM/YYYY'),
    TO_CHAR(end_date, 'DD/MM/YYYY'),
    total_users,
    new_users,
    COALESCE(new_users, 0),
    CASE WHEN total_users > 0 THEN ROUND((new_users::FLOAT / total_users::FLOAT) * 100, 1) ELSE 0 END,
    total_properties,
    new_properties,
    ROUND(avg_monthly_rent, 0),
    ROUND(total_rent_value, 0),
    total_applications,
    successful_applications,
    CASE WHEN total_applications > 0 THEN ROUND((successful_applications::FLOAT / total_applications::FLOAT) * 100, 1) ELSE 0 END,
    CASE WHEN previous_total_users > 0 THEN ROUND(((total_users - previous_total_users)::FLOAT / previous_total_users::FLOAT) * 100, 1) ELSE 0 END,
    CASE WHEN previous_total_properties > 0 THEN ROUND(((total_properties - previous_total_properties)::FLOAT / previous_total_properties::FLOAT) * 100, 1) ELSE 0 END,
    CASE WHEN total_applications > 0 THEN ROUND((successful_applications::FLOAT / total_applications::FLOAT) * 100, 1) ELSE 0 END
  );

  -- Créer le rapport
  INSERT INTO monthly_reports (
    title, month, year, status, metrics, comparison,
    executive_summary, generated_at, generated_by, generation_duration_ms,
    recipients
  ) VALUES (
    report_title,
    p_month,
    p_year,
    'generated',
    jsonb_build_object(
      'users', jsonb_build_object(
        'total', total_users,
        'new', new_users,
        'active', active_users,
        'growth_rate', CASE WHEN total_users > 0 THEN ROUND((new_users::FLOAT / total_users::FLOAT) * 100, 2) ELSE 0 END
      ),
      'properties', jsonb_build_object(
        'total', total_properties,
        'new', new_properties,
        'avg_monthly_rent', avg_monthly_rent,
        'total_rent_value', total_rent_value,
        'growth_rate', CASE WHEN total_properties > 0 THEN ROUND((new_properties::FLOAT / total_properties::FLOAT) * 100, 2) ELSE 0 END
      ),
      'applications', jsonb_build_object(
        'total', total_applications,
        'successful', successful_applications,
        'conversion_rate', CASE WHEN total_applications > 0 THEN ROUND((successful_applications::FLOAT / total_applications::FLOAT) * 100, 2) ELSE 0 END
      ),
      'region_breakdown', region_breakdown,
      'user_type_breakdown', user_type_breakdown
    ),
    jsonb_build_object(
      'previous_month', jsonb_build_object(
        'total_users', previous_total_users,
        'total_properties', previous_total_properties,
        'successful_applications', previous_successful_applications
      ),
      'month_over_month_growth', jsonb_build_object(
        'users_growth', CASE WHEN previous_total_users > 0 THEN ROUND(((total_users - previous_total_users)::FLOAT / previous_total_users::FLOAT) * 100, 2) ELSE 0 END,
        'properties_growth', CASE WHEN previous_total_properties > 0 THEN ROUND(((total_properties - previous_total_properties)::FLOAT / previous_total_properties::FLOAT) * 100, 2) ELSE 0 END,
        'applications_growth', CASE WHEN previous_successful_applications > 0 THEN ROUND(((successful_applications - previous_successful_applications)::FLOAT / previous_successful_applications::FLOAT) * 100, 2) ELSE 0 END
      )
    ),
    executive_summary,
    NOW(),
    current_user_id,
    EXTRACT(MILLISECOND FROM (NOW() - start_time))::INTEGER,
    ARRAY['admin@mon-toit.ci', 'management@mon-toit.ci']
  ) RETURNING id INTO report_id;

  -- Logger la génération
  INSERT INTO admin_audit_logs (
    admin_id, action_type, target_type, target_id, action_metadata
  ) VALUES (
    current_user_id,
    'monthly_report_generated',
    'monthly_report',
    report_id,
    jsonb_build_object(
      'month', p_month,
      'year', p_year,
      'generation_duration_ms', EXTRACT(MILLISECOND FROM (NOW() - start_time))::INTEGER,
      'metrics', jsonb_build_object(
        'total_users', total_users,
        'total_properties', total_properties,
        'total_applications', total_applications
      )
    )
  );

  RETURN report_id;
END;
$$;

-- Fonction pour obtenir les métriques d'un rapport mensuel
CREATE OR REPLACE FUNCTION get_monthly_report_metrics(
  p_start_date TIMESTAMPTZ,
  p_end_date TIMESTAMPTZ
)
RETURNS TABLE (
  total_users BIGINT,
  active_users BIGINT,
  new_users BIGINT,
  total_properties BIGINT,
  new_properties BIGINT,
  avg_monthly_rent DECIMAL(12,2),
  total_rent_value DECIMAL(15,2),
  total_applications BIGINT,
  successful_applications BIGINT,
  conversion_rate DECIMAL(5,2),
  user_growth_rate DECIMAL(5,2),
  property_growth_rate DECIMAL(5,2),
  region_breakdown JSONB,
  user_type_breakdown JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  start_date DATE := p_start_date::DATE;
  end_date DATE := p_end_date::DATE;
BEGIN
  RETURN QUERY
  WITH
  user_stats AS (
    SELECT
      COUNT(*) FILTER (WHERE created_at < start_date) as total_users,
      COUNT(DISTINCT us.user_id) FILTER (WHERE us.session_start >= start_date AND us.session_start <= end_date) as active_users,
      COUNT(*) FILTER (WHERE created_at >= start_date AND created_at <= end_date) as new_users
    FROM user_sessions us
    CROSS JOIN (SELECT 1) as dummy
  ),

  property_stats AS (
    SELECT
      COUNT(*) FILTER (WHERE created_at < start_date AND deleted_at IS NULL) as total_properties,
      COUNT(*) FILTER (WHERE created_at >= start_date AND created_at <= end_date AND deleted_at IS NULL) as new_properties,
      COALESCE(AVG(monthly_rent), 0) as avg_monthly_rent,
      COALESCE(SUM(monthly_rent), 0) as total_rent_value
    FROM properties
  ),

  application_stats AS (
    SELECT
      COUNT(*) as total_applications,
      COUNT(*) FILTER (WHERE status = 'approved') as successful_applications
    FROM rental_applications
    WHERE created_at >= start_date AND created_at <= end_date
  ),

  regions AS (
    SELECT jsonb_object_agg(city, property_count) as region_breakdown
    FROM (
      SELECT city, COUNT(*) as property_count
      FROM properties
      WHERE city IS NOT NULL AND deleted_at IS NULL
      GROUP BY city
      ORDER BY property_count DESC
      LIMIT 10
    ) region_data
  ),

  user_types AS (
    SELECT jsonb_object_agg(user_type, user_count) as user_type_breakdown
    FROM (
      SELECT user_type, COUNT(*) as user_count
      FROM profiles
      WHERE user_type IS NOT NULL
      GROUP BY user_type
    ) type_data
  )

  SELECT
    us.total_users,
    us.active_users,
    us.new_users,
    ps.total_properties,
    ps.new_properties,
    ps.avg_monthly_rent,
    ps.total_rent_value,
    aps.total_applications,
    aps.successful_applications,
    CASE
      WHEN aps.total_applications > 0 THEN
        ROUND((aps.successful_applications::DECIMAL / aps.total_applications::DECIMAL) * 100, 2)
      ELSE 0
    END as conversion_rate,
    CASE
      WHEN us.total_users > 0 THEN
        ROUND((us.new_users::DECIMAL / us.total_users::DECIMAL) * 100, 2)
      ELSE 0
    END as user_growth_rate,
    CASE
      WHEN ps.total_properties > 0 THEN
        ROUND((ps.new_properties::DECIMAL / ps.total_properties::DECIMAL) * 100, 2)
      ELSE 0
    END as property_growth_rate,
    r.region_breakdown,
    ut.user_type_breakdown
  FROM user_stats us, property_stats ps, application_stats aps, regions r, user_types ut;
END;
$$;

-- Fonction pour envoyer un rapport mensuel
CREATE OR REPLACE FUNCTION send_monthly_report(
  p_report_id UUID,
  p_recipients TEXT[] DEFAULT NULL
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  report_record RECORD;
  delivery_recipients TEXT[];
  current_user_id UUID := auth.uid();
  delivery_id UUID;
BEGIN
  -- Récupérer le rapport
  SELECT * INTO report_record
  FROM monthly_reports
  WHERE id = p_report_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Rapport non trouvé: %', p_report_id;
  END IF;

  -- Utiliser les destinataires fournis ou ceux par défaut
  delivery_recipients := COALESCE(p_recipients, report_record.recipients);

  -- Vérifier que le rapport est généré
  IF report_record.status != 'generated' THEN
    RAISE EXCEPTION 'Seuls les rapports générés peuvent être envoyés (statut actuel: %)', report_record.status;
  END IF;

  -- Créer les logs de livraison
  FOREACH recipient_email IN ARRAY delivery_recipients
  LOOP
    INSERT INTO report_delivery_logs (
      report_id, recipient_email, delivery_method
    ) VALUES (
      p_report_id,
      recipient_email,
      'email'
    ) RETURNING id INTO delivery_id;

    -- Simuler l'envoi (à remplacer par un appel réel à un service d'email)
    PERFORM supabase.functions.invoke('send-email', {
      body: jsonb_build_object(
        'to', recipient_email,
        'subject', report_record.title,
        'template', 'monthly_report',
        'data', jsonb_build_object(
          'report_id', p_report_id,
          'month', report_record.month,
          'year', report_record.year,
          'pdf_url', report_record.pdf_url,
          'executive_summary', report_record.executive_summary
        )
      )
    });

    -- Mettre à jour le statut de livraison
    UPDATE report_delivery_logs SET
      delivery_status = 'sent',
      sent_at = NOW(),
      delivery_duration_ms = 2000 -- Simulation
    WHERE id = delivery_id;
  END LOOP;

  -- Mettre à jour le statut du rapport
  UPDATE monthly_reports SET
    status = 'sent',
    sent_at = NOW(),
    recipients = delivery_recipients
  WHERE id = p_report_id;

  -- Logger l'envoi
  INSERT INTO admin_audit_logs (
    admin_id, action_type, target_type, target_id, action_metadata
  ) VALUES (
    current_user_id,
    'monthly_report_sent',
    'monthly_report',
    p_report_id,
    jsonb_build_object(
      'recipients_count', array_length(delivery_recipients, 1),
      'delivery_method', 'email',
      'month', report_record.month,
      'year', report_record.year
    )
  );

  RETURN TRUE;
END;
$$;

-- Fonction pour générer le CSV d'un rapport
CREATE OR REPLACE FUNCTION generate_report_csv(
  p_report_id UUID
)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  report_record RECORD;
  csv_content TEXT;
BEGIN
  -- Récupérer le rapport
  SELECT * INTO report_record
  FROM monthly_reports
  WHERE id = p_report_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Rapport non trouvé: %', p_report_id;
  END IF;

  -- Générer le contenu CSV
  csv_content := format(
    'Rapport Mensuel - %s/%s

Métriques Clés,Mois Actuel,Mois Précédent,Croissance (%)
Total utilisateurs,%s,,,
Nouveaux utilisateurs,%s,,,
Total propriétés,%s,,,
Nouvelles propriétés,%s,,,
Loyer moyen (FCFA),%s,,,
Taux de conversion (%%),%s,,
Répartition géographique,%s,,
Répartition types utilisateurs,%s,

Résumé Exécutif:
%s
',
    report_record.month,
    report_record.year,
    (report_record.metrics->>'users')->>'total',
    (report_record.metrics->>'users')->>'new',
    (report_record.metrics->>'properties')->>'total',
    (report_record.metrics->>'properties')->>'new',
    (report_record.metrics->>'properties')->>'avg_monthly_rent',
    (report_record.metrics->>'applications')->>'conversion_rate',
    report_record.metrics->>'region_breakdown',
    report_record.metrics->>'user_type_breakdown',
    report_record.executive_summary
  );

  RETURN csv_content;
END;
$$;

-- Trigger pour mettre à jour le timestamp updated_at
CREATE OR REPLACE FUNCTION update_monthly_reports_timestamp()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Créer le trigger
CREATE TRIGGER update_monthly_reports_timestamp
  BEFORE UPDATE ON monthly_reports
  FOR EACH ROW
  EXECUTE FUNCTION update_monthly_reports_timestamp();

-- RLS Policies
ALTER TABLE monthly_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE report_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE report_delivery_logs ENABLE ROW LEVEL SECURITY;

-- Policy: Seuls les admins peuvent voir les rapports
CREATE POLICY "Admins can view monthly reports" ON monthly_reports
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = auth.uid()
    AND role IN ('admin', 'super_admin')
  )
);

-- Policy: Seuls les admins peuvent créer des rapports
CREATE POLICY "Admins can create monthly reports" ON monthly_reports
FOR INSERT WITH CHECK (
  EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = auth.uid()
    AND role IN ('admin', 'super_admin')
  )
);

-- Policy: Seuls les admins peuvent modifier les rapports
CREATE POLICY "Admins can update monthly reports" ON monthly_reports
FOR UPDATE USING (
  EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = auth.uid()
    AND role IN ('admin', 'super_admin')
  )
);

-- Policies similaires pour les autres tables
CREATE POLICY "Admins can manage report templates" ON report_templates
FOR ALL USING (
  EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = auth.uid()
    AND role IN ('admin', 'super_admin')
  )
);

CREATE POLICY "Admins can view delivery logs" ON report_delivery_logs
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = auth.uid()
    AND role IN ('admin', 'super_admin')
  )
);

-- Index pour optimiser les performances
CREATE INDEX IF NOT EXISTS idx_monthly_reports_month_year ON monthly_reports(month, year);
CREATE INDEX IF NOT EXISTS idx_monthly_reports_status ON monthly_reports(status);
CREATE INDEX IF NOT EXISTS idx_monthly_reports_created_at ON monthly_reports(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_report_delivery_logs_report_id ON report_delivery_logs(report_id);
CREATE INDEX IF NOT EXISTS idx_report_delivery_logs_status ON report_delivery_logs(delivery_status);

-- Insérer des modèles par défaut
INSERT INTO report_templates (name, description, type, template_config, is_default, is_active) VALUES
(
  'Rapport Mensuel Standard',
  'Modèle standard pour les rapports mensuels de performance',
  'monthly_performance',
  '{"sections": ["executive_summary", "user_metrics", "property_metrics", "application_metrics", "comparison"], "format": "pdf_csv"}',
  '{"colors": {"primary": "#2563eb", "secondary": "#64748b"}, "logo": true}',
  true,
  true
),
(
  'Rapport Trimestriel Détaillé',
  'Rapport détaillé pour les revues trimestrielles',
  'quarterly_review',
  '{"sections": ["quarterly_summary", "detailed_metrics", "trends", "forecasts"], "format": "excel"}',
  '{"colors": {"primary": "#059669", "secondary": "#6b7280"}, "charts": true}',
  false,
  true
) ON CONFLICT DO NOTHING;

-- Commentaires sur les tables
COMMENT ON TABLE monthly_reports IS 'Stocke les rapports mensuels générés automatiquement';
COMMENT ON TABLE report_templates IS 'Modèles configurables pour la génération de rapports';
COMMENT ON TABLE report_delivery_logs IS 'Journal de suivi de la livraison des rapports';

-- Commentaires sur les fonctions principales
COMMENT ON FUNCTION generate_monthly_report() IS 'Génère un rapport mensuel complet avec toutes les métriques';
COMMENT ON FUNCTION get_monthly_report_metrics() IS 'Calcule les métriques détaillées pour une période donnée';
COMMENT ON FUNCTION send_monthly_report() IS 'Envoie un rapport mensuel aux destinataires par email';
COMMENT ON FUNCTION generate_report_csv() IS 'Génère le contenu CSV formaté pour un rapport';