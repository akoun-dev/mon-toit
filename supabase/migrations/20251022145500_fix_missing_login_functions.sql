-- Fix missing login functions and tables after migration issues
-- This migration recreates the missing elements needed for authentication

-- First, check and update the existing login_attempts table structure
DO $$
BEGIN
  -- Check if table exists and add missing columns
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'login_attempts' AND table_schema = 'public') THEN
    -- Add missing columns if they don't exist
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'login_attempts' AND column_name = 'attempt_date') THEN
      ALTER TABLE public.login_attempts ADD COLUMN attempt_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW();
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'login_attempts' AND column_name = 'blocked_until') THEN
      ALTER TABLE public.login_attempts ADD COLUMN blocked_until TIMESTAMP WITH TIME ZONE;
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'login_attempts' AND column_name = 'threat_score') THEN
      ALTER TABLE public.login_attempts ADD COLUMN threat_score INTEGER DEFAULT 0;
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'login_attempts' AND column_name = 'metadata') THEN
      ALTER TABLE public.login_attempts ADD COLUMN metadata JSONB DEFAULT '{}';
    END IF;
  ELSE
    -- Create the table if it doesn't exist
    CREATE TABLE public.login_attempts (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      email TEXT NOT NULL,
      ip_address INET NOT NULL,
      user_agent TEXT,
      success BOOLEAN NOT NULL DEFAULT FALSE,
      attempt_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
      blocked_until TIMESTAMP WITH TIME ZONE,
      threat_score INTEGER DEFAULT 0,
      metadata JSONB DEFAULT '{}'
    );
  END IF;
END $$;

-- Create indexes for login_attempts
CREATE INDEX IF NOT EXISTS idx_login_attempts_email_time ON public.login_attempts(email, attempt_date);
CREATE INDEX IF NOT EXISTS idx_login_attempts_ip_time ON public.login_attempts(ip_address, attempt_date);
CREATE INDEX IF NOT EXISTS idx_login_attempts_blocked_until ON public.login_attempts(blocked_until) WHERE blocked_until IS NOT NULL;

-- Recreate check_login_rate_limit function
CREATE OR REPLACE FUNCTION public.check_login_rate_limit(_email text, _ip_address text)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  attempt_count integer;
  is_blocked boolean := FALSE;
  block_duration_minutes integer := 15;
  remaining_attempts integer := 5;
  reset_time timestamp with time zone;
BEGIN
  -- Check if email is currently blocked
  SELECT EXISTS(
    SELECT 1 FROM public.login_attempts
    WHERE email = _email
    AND blocked_until > NOW()
  ) INTO is_blocked;

  IF is_blocked THEN
    -- Get block duration remaining
    SELECT blocked_until INTO reset_time
    FROM public.login_attempts
    WHERE email = _email
    AND blocked_until > NOW()
    ORDER BY blocked_until DESC
    LIMIT 1;

    RETURN jsonb_build_object(
      'allowed', false,
      'blocked', true,
      'reset_time', reset_time,
      'message', 'Too many failed attempts. Please try again later.'
    );
  END IF;

  -- Count recent failed attempts in last 15 minutes
  SELECT COUNT(*) INTO attempt_count
  FROM public.login_attempts
  WHERE email = _email
  AND success = false
  AND attempt_date > NOW() - INTERVAL '15 minutes';

  remaining_attempts := GREATEST(0, 5 - attempt_count);

  -- If too many attempts, block the email
  IF attempt_count >= 5 THEN
    UPDATE public.login_attempts
    SET blocked_until = NOW() + INTERVAL '15 minutes'
    WHERE email = _email
    AND success = false
    AND attempt_date > NOW() - INTERVAL '15 minutes';

    reset_time := NOW() + INTERVAL '15 minutes';

    RETURN jsonb_build_object(
      'allowed', false,
      'blocked', true,
      'reset_time', reset_time,
      'message', 'Too many failed attempts. Account temporarily blocked.'
    );
  END IF;

  RETURN jsonb_build_object(
    'allowed', true,
    'blocked', false,
    'remaining_attempts', remaining_attempts,
    'message', 'Login attempt allowed'
  );
END;
$$;

-- Recreate function to log login attempts
CREATE OR REPLACE FUNCTION public.log_login_attempt(
  _email text,
  _ip_address inet,
  _user_agent text,
  _success boolean,
  _threat_score integer DEFAULT 0
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.login_attempts (
    email,
    ip_address,
    user_agent,
    success,
    threat_score,
    metadata
  ) VALUES (
    _email,
    _ip_address,
    _user_agent,
    _success,
    _threat_score,
    jsonb_build_object('logged_at', NOW())
  );
END;
$$;

-- Enable RLS on login_attempts if not already enabled
ALTER TABLE public.login_attempts ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view their own login attempts" ON public.login_attempts;
DROP POLICY IF EXISTS "Users can insert their own login attempts" ON public.login_attempts;

-- Create RLS policies for login_attempts
CREATE POLICY "Users can view their own login attempts" ON public.login_attempts
  FOR SELECT USING (
    email = current_setting('app.current_email', true)
    OR EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid()
      AND user_type = 'admin'
    )
  );

CREATE POLICY "Users can insert their own login attempts" ON public.login_attempts
  FOR INSERT WITH CHECK (true);

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.check_login_rate_limit(text, text) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.log_login_attempt(text, inet, text, boolean, integer) TO anon, authenticated;
GRANT SELECT ON public.login_attempts TO authenticated;

