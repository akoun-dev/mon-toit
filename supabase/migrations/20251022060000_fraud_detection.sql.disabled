-- Migration pour la Détection de Fraude et Rate Limiting
-- Implémentation complète du système de sécurité et prévention

-- Table principale pour les alertes de fraude
CREATE TABLE IF NOT EXISTS fraud_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  alert_type VARCHAR(50) NOT NULL CHECK (alert_type IN (
    'account_takeover',
    'fake_account',
    'suspicious_activity',
    'multiple_accounts',
    'payment_fraud',
    'identity_theft',
    'bot_attack',
    'credential_stuffing'
  )),
  severity VARCHAR(20) NOT NULL CHECK (severity IN (
    'low', 'medium', 'high', 'critical'
  )),
  status VARCHAR(50) NOT NULL DEFAULT 'open' CHECK (status IN (
    'open', 'investigating', 'resolved', 'false_positive', 'escalated'
  )),

  -- Score de risque et description
  risk_score INTEGER NOT NULL CHECK (risk_score >= 0 AND risk_score <= 100),
  description TEXT NOT NULL,
  evidence JSONB DEFAULT '{}',

  -- Informations de détection
  ip_address INET NOT NULL,
  user_agent TEXT,
  device_fingerprint VARCHAR(255),
  geolocation JSONB DEFAULT '{}',

  -- Investigation
  investigated_by UUID REFERENCES auth.users(id),
  investigation_notes TEXT,
  resolution_details JSONB DEFAULT '{}',
  escalated_to UUID REFERENCES auth.users(id),

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  resolved_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Table pour les règles de rate limiting
CREATE TABLE IF NOT EXISTS rate_limit_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  description TEXT,
  rule_type VARCHAR(50) NOT NULL CHECK (rule_type IN (
    'login_attempts',
    'account_creation',
    'api_requests',
    'password_reset',
    'contact_form',
    'property_submission',
    'message_sending'
  )),
  target_type VARCHAR(50) NOT NULL CHECK (target_type IN (
    'ip_address',
    'email_domain',
    'user_account',
    'device_fingerprint',
    'geographic_region'
  )),

  -- Configuration des limites
  window_minutes INTEGER NOT NULL DEFAULT 15,
  max_attempts INTEGER NOT NULL DEFAULT 5,
  penalty_duration_minutes INTEGER NOT NULL DEFAULT 60,
  is_active BOOLEAN DEFAULT TRUE,

  -- Auto-block et notification
  auto_block_enabled BOOLEAN DEFAULT TRUE,
  auto_block_threshold INTEGER DEFAULT 10,
  notification_enabled BOOLEAN DEFAULT TRUE,
  escalation_threshold INTEGER DEFAULT 20,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Table pour le suivi des blocages rate limiting
CREATE TABLE IF NOT EXISTS rate_limit_blocks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  rule_id UUID REFERENCES rate_limit_rules(id) ON DELETE CASCADE,
  target_value VARCHAR(255) NOT NULL,
  target_type VARCHAR(50) NOT NULL,
  blocked_at TIMESTAMPTZ DEFAULT NOW(),
  blocked_until TIMESTAMPTZ NOT NULL,
  attempts_count INTEGER DEFAULT 1,

  -- Déblocage
  unblocked_by UUID REFERENCES auth.users(id),
  unblocked_at TIMESTAMPTZ,
  unblock_reason TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Table pour les tentatives de connexion (pour détection d'anomalies)
CREATE TABLE IF NOT EXISTS login_anomalies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  ip_address INET NOT NULL,
  user_agent TEXT,
  device_fingerprint VARCHAR(255),
  anomaly_type VARCHAR(50) NOT NULL CHECK (anomaly_type IN (
    'impossible_location',
    'multiple_ips',
    'unusual_device',
    'brute_force',
    'timing_pattern',
    'velocity_anomaly',
    'credential_stuffing'
  )),
  anomaly_score DECIMAL(5,2) CHECK (anomaly_score >= 0 AND anomaly_score <= 100),
  context_data JSONB DEFAULT '{}',

  detected_at TIMESTAMPTZ DEFAULT NOW(),
  resolved BOOLEAN DEFAULT FALSE,
  resolved_at TIMESTAMPTZ
);

-- Table pour le suivi des appareils suspects
CREATE TABLE IF NOT EXISTS suspicious_devices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  device_fingerprint VARCHAR(255) UNIQUE NOT NULL,
  user_agent TEXT,
  first_seen TIMESTAMPTZ DEFAULT NOW(),
  last_seen TIMESTAMPTZ DEFAULT NOW(),
  associated_users UUID[] DEFAULT '{}',
  alert_count INTEGER DEFAULT 1,
  risk_level VARCHAR(20) DEFAULT 'medium' CHECK (risk_level IN (
    'low', 'medium', 'high', 'critical'
  )),
  notes TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Table pour les patterns de fraude détectés
CREATE TABLE IF NOT EXISTS fraud_patterns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pattern_name VARCHAR(100) NOT NULL,
  pattern_type VARCHAR(50) NOT NULL CHECK (pattern_type IN (
    'email_pattern',
    'ip_pattern',
    'behavioral_pattern',
    'transaction_pattern',
    'temporal_pattern'
  )),
  pattern_regex TEXT,
  description TEXT,

  -- Configuration
  confidence_threshold DECIMAL(5,2) DEFAULT 0.8,
  auto_block BOOLEAN DEFAULT TRUE,
  is_active BOOLEAN DEFAULT TRUE,

  -- Statistiques
  detection_count INTEGER DEFAULT 0,
  false_positive_count INTEGER DEFAULT 0,
  last_detection TIMESTAMPTZ,

  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Fonction pour détecter automatiquement les fraudes
CREATE OR REPLACE FUNCTION detect_fraud_activity(
  p_user_id UUID,
  p_action_type VARCHAR(50),
  p_ip_address INET,
  p_user_agent TEXT,
  p_device_fingerprint VARCHAR(255) DEFAULT NULL
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  anomaly_found BOOLEAN := FALSE;
  anomaly_score DECIMAL(5,2) := 0;
  anomaly_type VARCHAR(50);
  blocked_count INTEGER;
  alert_id UUID;
BEGIN
  -- Vérifier les règles de rate limiting
  SELECT COUNT(*) INTO blocked_count
  FROM rate_limit_blocks
  WHERE target_value = p_ip_address::TEXT
  AND target_type = 'ip_address'
  AND blocked_until > NOW();

  IF blocked_count > 0 THEN
    -- Créer une alerte de blocage
    INSERT INTO fraud_alerts (
      user_id, alert_type, severity, risk_score, description,
      ip_address, user_agent, device_fingerprint, evidence
    ) VALUES (
      p_user_id,
      'suspicious_activity',
      'high',
      80,
      format('L''adresse IP %s est actuellement bloquée pour %s tentatives excessives', p_ip_address, blocked_count),
      p_ip_address,
      p_user_agent,
      p_device_fingerprint,
      jsonb_build_object(
        'blocked_count', blocked_count,
        'rule_type', 'rate_limiting'
      )
    ) RETURNING id INTO alert_id;

    RETURN TRUE;
  END IF;

  -- Analyser les anomalies de connexion
  -- Vérifier les connexions multiples depuis différentes IPs récemment
  SELECT COUNT(DISTINCT ip_address) INTO anomaly_score
  FROM login_attempts
  WHERE user_id = p_user_id
  AND created_at >= NOW() - INTERVAL '1 hour'
  AND success = TRUE;

  IF anomaly_score > 3 THEN
    anomaly_type := 'multiple_ips';
    anomaly_score := LEAST(anomaly_score * 20, 100);
    anomaly_found := TRUE;
  END IF;

  -- Vérifier les tentatives dans un temps anormalement court
  SELECT COUNT(*) INTO blocked_count
  FROM login_attempts
  WHERE user_id = p_user_id
  AND created_at >= NOW() - INTERVAL '1 minute'
  AND success = FALSE;

  IF blocked_count >= 5 THEN
    anomaly_type := 'velocity_anomaly';
    anomaly_score := LEAST(blocked_count * 15, 100);
    anomaly_found := TRUE;
  END IF;

  -- Créer une alerte si une anomalie est détectée
  IF anomaly_found AND anomaly_score >= 50 THEN
    INSERT INTO fraud_alerts (
      user_id, alert_type, severity, risk_score, description,
      ip_address, user_agent, device_fingerprint, evidence
    ) VALUES (
      p_user_id,
      'suspicious_activity',
      CASE WHEN anomaly_score >= 80 THEN 'critical' ELSE 'high' END,
      ROUND(anomaly_score)::INTEGER,
      format('Anomalie de type %s détectée avec un score de risque de %s', anomaly_type, anomaly_score),
      p_ip_address,
      p_user_agent,
      p_device_fingerprint,
      jsonb_build_object(
        'anomaly_type', anomaly_type,
        'anomaly_score', anomaly_score,
        'detection_method', 'behavioral_analysis'
      )
    );

    -- Logger l'anomalie
    INSERT INTO login_anomalies (
      user_id, ip_address, user_agent, device_fingerprint,
      anomaly_type, anomaly_score, context_data
    ) VALUES (
      p_user_id,
      p_ip_address,
      p_user_agent,
      p_device_fingerprint,
      anomaly_type,
      anomaly_score,
      jsonb_build_object(
        'action_type', p_action_type,
        'detection_timestamp', NOW()
      )
    );
  END IF;

  RETURN anomaly_found;
END;
$$;

-- Fonction pour vérifier les limites de débit
CREATE OR REPLACE FUNCTION check_rate_limit(
  p_identifier VARCHAR(255),
  p_rule_type VARCHAR(50),
  p_value VARCHAR(255) DEFAULT NULL
)
RETURNS TABLE (
  allowed BOOLEAN,
  reason TEXT,
  retry_after VARCHAR(255),
  blocked BOOLEAN,
  show_captcha BOOLEAN,
  failed_count INTEGER
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  rule RECORD;
  attempt_count INTEGER;
  window_start TIMESTAMPTZ;
  failed_count INTEGER;
BEGIN
  -- Récupérer la règle de rate limiting applicable
  SELECT * INTO rule
  FROM rate_limit_rules
  WHERE rule_type = p_rule_type
  AND is_active = TRUE
  ORDER BY priority DESC, window_minutes ASC
  LIMIT 1;

  IF NOT FOUND THEN
    RETURN QUERY SELECT TRUE, NULL, NULL, FALSE, FALSE, 0;
  END IF;

  -- Calculer le début de la fenêtre
  window_start := NOW() - (rule.window_minutes || ' minutes')::INTERVAL;

  -- Compter les tentatives dans la fenêtre
  IF p_rule_type = 'login_attempts' THEN
    SELECT COUNT(*) INTO attempt_count
    FROM login_attempts
    WHERE (p_value IS NULL AND ip_address = p_identifier) OR
          (p_value IS NOT NULL AND user_id = p_identifier::UUID)
    AND created_at >= window_start;
  ELSE
    -- Pour les autres types, implémentation de base
    attempt_count := 0;
  END IF;

  -- Compter les échecs récents
  SELECT COUNT(*) INTO failed_count
  FROM login_attempts
  WHERE success = FALSE
  AND ((p_value IS NULL AND ip_address = p_identifier) OR
       (p_value IS NOT NULL AND user_id = p_identifier::UUID))
  AND created_at >= window_start;

  -- Déterminer si l'action est autorisée
  IF attempt_count >= rule.max_attempts THEN
    -- Dépassé la limite - créer un blocage si nécessaire
    IF rule.auto_block_enabled AND attempt_count >= rule.auto_block_threshold THEN
      INSERT INTO rate_limit_blocks (
        rule_id, target_value, target_type, blocked_until, attempts_count
      ) VALUES (
        rule.id,
        COALESCE(p_value, p_identifier),
        CASE WHEN p_value IS NULL THEN 'ip_address' ELSE 'user_account' END,
        NOW() + (rule.penalty_duration_minutes || ' minutes')::INTERVAL,
        attempt_count
      );
    END IF;

    RETURN QUERY SELECT
      FALSE,
      format('Limite de débit dépassée: %s tentatives en %d minutes', attempt_count, rule.window_minutes),
      format('%d minutes', rule.penalty_duration_minutes),
      attempt_count >= rule.auto_block_threshold,
      attempt_count >= rule.auto_block_threshold,
      failed_count
    ;
  ELSE
    RETURN QUERY SELECT TRUE, NULL, NULL, FALSE, FALSE, failed_count;
  END IF;
END;
$$;

-- Fonction pour créer une alerte de fraude manuelle
CREATE OR REPLACE FUNCTION create_fraud_alert(
  p_user_id UUID,
  p_alert_type VARCHAR(50),
  p_severity VARCHAR(20),
  p_risk_score INTEGER,
  p_description TEXT,
  p_evidence JSONB DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  alert_id UUID;
  current_user_id UUID := auth.uid();
BEGIN
  -- Vérifier les permissions
  IF NOT EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = current_user_id
    AND role IN ('admin', 'super_admin')
  ) THEN
    RAISE EXCEPTION 'Permission refusée: rôle admin requis';
  END IF;

  -- Créer l'alerte
  INSERT INTO fraud_alerts (
    user_id, alert_type, severity, risk_score, description,
    ip_address, user_agent, device_fingerprint, evidence, investigated_by
  ) VALUES (
    p_user_id,
    p_alert_type,
    p_severity,
    p_risk_score,
    p_description,
    '0.0.0.0', -- IP par défaut si non spécifiée
    'Manual alert creation',
    NULL,
    p_evidence,
    current_user_id
  ) RETURNING id INTO alert_id;

  -- Logger la création d'alerte
  INSERT INTO admin_audit_logs (
    admin_id, action_type, target_type, target_id, action_metadata
  ) VALUES (
    current_user_id,
    'fraud_alert_created',
    'fraud_alert',
    alert_id,
    jsonb_build_object(
      'alert_type', p_alert_type,
      'severity', p_severity,
      'risk_score', p_risk_score,
      'manual_creation', TRUE
    )
  );

  RETURN alert_id;
END;
$$;

-- Fonction pour résoudre une alerte de fraude
CREATE OR REPLACE FUNCTION resolve_fraud_alert(
  p_alert_id UUID,
  p_resolution VARCHAR(50) DEFAULT NULL,
  p_investigation_notes TEXT DEFAULT NULL
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  alert_record RECORD;
  current_user_id UUID := auth.uid();
  is_admin BOOLEAN;
BEGIN
  -- Vérifier les permissions
  SELECT EXISTS(
    SELECT 1 FROM user_roles
    WHERE user_id = current_user_id
    AND role IN ('admin', 'super_admin')
  ) INTO is_admin;

  IF NOT is_admin THEN
    RAISE EXCEPTION 'Permission refusée: rôle admin requis';
  END IF;

  -- Récupérer l'alerte
  SELECT * INTO alert_record
  FROM fraud_alerts
  WHERE id = p_alert_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Alerte de fraude non trouvée: %', p_alert_id;
  END IF;

  -- Mettre à jour l'alerte
  UPDATE fraud_alerts SET
    status = CASE
      WHEN p_resolution IN ('resolved', 'false_positive') THEN p_resolution
      WHEN p_investigation_notes IS NOT NULL THEN 'investigating'
      ELSE status
    END,
    investigated_by = current_user_id,
    investigation_notes = p_investigation_notes,
    resolved_at = CASE
      WHEN p_resolution IN ('resolved', 'false_positive') THEN NOW()
      ELSE resolved_at
    END,
    resolution_details = jsonb_build_object(
      'resolution', p_resolution,
      'investigation_notes', p_investigation_notes,
      'resolved_by', current_user_id
    ),
    updated_at = NOW()
  WHERE id = p_alert_id;

  -- Logger la résolution
  INSERT INTO admin_audit_logs (
    admin_id, action_type, target_type, target_id, action_metadata
  ) VALUES (
    current_user_id,
    'fraud_alert_resolved',
    'fraud_alert',
    p_alert_id,
    jsonb_build_object(
      'resolution', p_resolution,
      'alert_type', alert_record.alert_type,
      'severity', alert_record.severity,
      'risk_score', alert_record.risk_score,
      'investigation_notes', p_investigation_notes
    )
  );

  RETURN TRUE;
END;
$$;

-- Fonction pour obtenir les métriques de détection de fraude
CREATE OR REPLACE FUNCTION get_fraud_detection_metrics()
RETURNS TABLE (
  total_alerts BIGINT,
  open_alerts BIGINT,
  critical_alerts BIGINT,
  false_positives BIGINT,
  resolved_alerts BIGINT,
  avg_resolution_time_hours DECIMAL(8,2),
  alerts_by_type JSONB,
  alerts_by_severity JSONB,
  trend_7_days BIGINT,
  trend_30_days BIGINT,
  blocked_attempts BIGINT,
  active_rate_limits BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH metrics AS (
    SELECT
      COUNT(*) as total_alerts,
      COUNT(*) FILTER (WHERE status = 'open') as open_alerts,
      COUNT(*) FILTER (WHERE severity = 'critical') as critical_alerts,
      COUNT(*) FILTER (WHERE status = 'false_positive') as false_positives,
      COUNT(*) FILTER (WHERE status = 'resolved') as resolved_alerts,
      AVG(EXTRACT(HOUR FROM (resolved_at - created_at))) FILTER (WHERE resolved_at IS NOT NULL) as avg_resolution_time,

      -- Répartition par type
      (SELECT jsonb_object_agg(alert_type, type_count)
       FROM (
         SELECT alert_type, COUNT(*) as type_count
         FROM fraud_alerts
         GROUP BY alert_type
       ) type_stats),

      -- Répartition par sévérité
      (SELECT jsonb_object_agg(severity, severity_count)
       FROM (
         SELECT severity, COUNT(*) as severity_count
         FROM fraud_alerts
         GROUP BY severity
       ) severity_stats),

      -- Tendances
      COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '7 days') as trend_7_days,
      COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '30 days') as trend_30_days
    FROM fraud_alerts
  ),

  rate_limits AS (
    SELECT
      COUNT(*) as active_rate_limits,
      COUNT(*) as blocked_attempts
    FROM rate_limit_rules rl
    LEFT JOIN rate_limit_blocks rb ON rl.id = rb.rule_id AND rb.blocked_until > NOW()
    WHERE rl.is_active = true
  )

  SELECT
    m.total_alerts,
    m.open_alerts,
    m.critical_alerts,
    m.false_positives,
    m.resolved_alerts,
    COALESCE(m.avg_resolution_time, 0),
    COALESCE(m.alerts_by_type, '{}'),
    COALESCE(m.alerts_by_severity, '{}'),
    m.trend_7_days,
    m.trend_30_days,
    COALESCE(rl.blocked_attempts, 0),
    COALESCE(rl.active_rate_limits, 0)
  FROM metrics m
  CROSS JOIN rate_limits rl
  LIMIT 1;
END;
$$;

-- Trigger pour mettre à jour les timestamps
CREATE OR REPLACE FUNCTION update_fraud_detection_timestamps()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Créer les triggers
CREATE TRIGGER update_fraud_alerts_timestamp
  BEFORE UPDATE ON fraud_alerts
  FOR EACH ROW
  EXECUTE FUNCTION update_fraud_detection_timestamps();

CREATE TRIGGER update_rate_limit_rules_timestamp
  BEFORE UPDATE ON rate_limit_rules
  FOR EACH ROW
  EXECUTE FUNCTION update_fraud_detection_timestamps();

CREATE TRIGGER update_suspicious_devices_timestamp
  BEFORE UPDATE ON suspicious_devices
  FOR EACH ROW
  EXECUTE FUNCTION update_fraud_detection_timestamps();

-- RLS Policies
ALTER TABLE fraud_alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE rate_limit_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE rate_limit_blocks ENABLE ROW LEVEL SECURITY;
ALTER TABLE login_anomalies ENABLE ROW LEVEL SECURITY;
ALTER TABLE suspicious_devices ENABLE ROW LEVEL SECURITY;
ALTER TABLE fraud_patterns ENABLE ROW LEVEL SECURITY;

-- Policies pour les alertes de fraude
CREATE POLICY "Admins can view fraud alerts" ON fraud_alerts
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = auth.uid()
    AND role IN ('admin', 'super_admin')
  )
);

CREATE POLICY "Admins can manage fraud alerts" ON fraud_alerts
FOR ALL USING (
  EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = auth.uid()
    AND role IN ('admin', 'super_admin')
  )
);

-- Policies similaires pour les autres tables
CREATE POLICY "Admins can manage rate limiting" ON rate_limit_rules
FOR ALL USING (
  EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = auth.uid()
    AND role IN ('admin', 'super_admin')
  )
);

CREATE POLICY "Admins can view fraud metrics" ON login_anomalies
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = auth.uid()
    AND role IN ('admin', 'super_admin')
  )
);

-- Index pour optimiser les performances
CREATE INDEX IF NOT EXISTS idx_fraud_alerts_user_id ON fraud_alerts(user_id);
CREATE INDEX IF NOT EXISTS idx_fraud_alerts_status ON fraud_alerts(status);
CREATE INDEX IF NOT EXISTS idx_fraud_alerts_severity ON fraud_alerts(severity);
CREATE INDEX IF NOT EXISTS idx_fraud_alerts_created_at ON fraud_alerts(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_fraud_alerts_risk_score ON fraud_alerts(risk_score);
CREATE INDEX IF NOT EXISTS idx_rate_limit_blocks_target ON rate_limit_blocks(target_value, target_type);
CREATE INDEX IF NOT EXISTS idx_rate_limit_blocks_blocked_until ON rate_limit_blocks(blocked_until);
CREATE INDEX IF NOT EXISTS idx_login_anomalies_user_id ON login_anomalies(user_id);
CREATE INDEX IF NOT EXISTS idx_login_anomalies_detected_at ON login_anomalies(detected_at DESC);
CREATE INDEX IF NOT EXISTS idx_suspicious_devices_fingerprint ON suspicious_devices(device_fingerprint);

-- Insérer des règles de rate limiting par défaut
INSERT INTO rate_limit_rules (name, description, rule_type, window_minutes, max_attempts, penalty_duration_minutes, auto_block_enabled, auto_block_threshold) VALUES
(
  'Login Rate Limiting',
  'Limite le nombre de tentatives de connexion par IP et par utilisateur',
  'login_attempts',
  15,
  5,
  30,
  true,
  8
),
(
  'Account Creation Limiting',
  'Limite la création de comptes par IP et par domaine email',
  'account_creation',
  60,
  3,
  360,
  true,
  5
),
(
  'Password Reset Limiting',
  'Limite les demandes de réinitialisation par IP',
  'password_reset',
  60,
  3,
  180,
  false,
  10
),
(
  'API Rate Limiting',
  'Limite les requêtes API par clé et par IP',
  'api_requests',
  1,
  100,
  60,
  false,
  200
),
(
  'Contact Form Limiting',
  'Limite les soumissions de formulaire de contact',
  'contact_form',
  60,
  5,
  120,
  false,
  15
),
(
  'Property Submission Limiting',
  'Limite les soumissions de propriétés par utilisateur',
  'property_submission',
  60,
  3,
  240,
  false,
  10
) ON CONFLICT DO NOTHING;

-- Insérer des patterns de fraude par défaut
INSERT INTO fraud_patterns (pattern_name, pattern_type, pattern_regex, description, confidence_threshold, auto_block) VALUES
(
  'Disposable Email Addresses',
  'email_pattern',
  '(mailinator\.com|10minutemail\.com|guerrillamail\.com|tempmail\.org|yopmail\.com)',
  'Détection des adresses email temporaires jetables',
  0.9,
  true
),
(
  'VPN and Proxy IP Ranges',
  'ip_pattern',
  '(10\.0\.0\.0/8|172\.16\.0\.0/12|192\.168\.0\.0/16)',
  'Détection des connexions via VPN ou proxy',
  0.8,
  true
),
(
  'High Velocity Account Creation',
  'behavioral_pattern',
  'Création de comptes multiples en peu de temps',
  NULL,
  'Détection de création rapide de comptes suspects',
  0.85,
  true
),
(
  'Suspicious User Agents',
  'behavioral_pattern',
  '(bot|crawler|scraper|curl|wget)',
  'Détection des user agents automatisés ou suspects',
  0.7,
  false
) ON CONFLICT DO NOTHING;

-- Commentaires sur les tables
COMMENT ON TABLE fraud_alerts IS 'Alertes de fraude détectées automatiquement ou créées manuellement';
COMMENT ON TABLE rate_limit_rules IS 'Règles configurables de rate limiting pour différentes actions';
COMMENT ON TABLE rate_limit_blocks IS 'Journal des blocages automatiques suite au rate limiting';
COMMENT ON TABLE login_anomalies IS 'Détection d''anomalies dans les patterns de connexion utilisateur';
COMMENT ON TABLE suspicious_devices IS 'Suivi des appareils et empreintes digitales suspects';
COMMENT ON TABLE fraud_patterns IS 'Patterns et signatures connus de fraude pour détection automatique';

-- Commentaires sur les fonctions principales
COMMENT ON FUNCTION detect_fraud_activity() IS 'Détecte automatiquement les activités frauduleuses basées sur les patterns de comportement';
COMMENT ON FUNCTION check_rate_limit() IS 'Vérifie si une action respecte les limites de débit configurées';
COMMENT ON FUNCTION create_fraud_alert() IS 'Crée manuellement une alerte de fraude avec scoring de risque';
COMMENT ON FUNCTION resolve_fraud_alert() IS 'Traite et résout une alerte de fraude avec suivi complet';
COMMENT ON FUNCTION get_fraud_detection_metrics() IS 'Calcule les métriques agrégées pour le dashboard de détection de fraude';